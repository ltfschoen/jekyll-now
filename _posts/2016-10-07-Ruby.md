---
layout: post
title: Ruby (in progress!)
---

# Table of Contents
  * [Chapter 1 - Pending](#chapter-1)

## Chapter 1 - Pending <a id="chapter-1"></a>

### Interactive Ruby Shell

{% highlight bash %}
irb
{% endhighlight %}

### Executable Ruby Programs

* Run plain Ruby file

{% highlight bash %}
ruby main.rb
{% endhighlight %}

* Run executable file having shebang notation at start of file (i.e. `#!/usr/bin/ruby`)

{% highlight bash %}
./main.rb
{% endhighlight %}

### Ruby Object-Oriented Terms

* Objects are created and manipulated from a Class.
* Entities modelled in code based on real world concepts into categories are represented by Classes (variable state and methods using it)
* Classes define:
* Class Instances (Objects) created derived based on same base Class using Constructor method `new`
* Class Instances have
- Object Identifier (unique)
- Object Instance Variables (Object State)
- Object Instance Methods (invoke by calling method on receiver with message containing method name and parameters)
- Accessibility Constraints 

### Ruby Debugging

- `puts`

### Ruby Code Evaluation, Convention and Styling

* Parentheses used due to precedence rules (i.e. `puts(foo('hi'))`)
* String literals single quote minimal processing (i.e. `puts('line1\nline2')`)
* String literals double quote higher processing (i.e. `puts("line1\nline2")`)
  - Substitutes sequences with binary (i.e. `\n` with new line character)
  - Expresson Interpolation of sequences `#{expression}`
* Last expression evaluated in method is returned (i.e. `return` not required) is Idiomatic Ruby
* Naming Conventions:
  - Local variables, method parameters/names - start with lowercase letter or `_`
  - Global variables - prefix with `$`
  - Instance variables (multiword) - start with `@` (i.e. `@foo_bar`)
  - Class variables - start with `@@foo_bar`
  - Class/Module names and Constants - start with uppercase letter camelcase (i.e. class `FooBar`)
  - Constants - capitalised (i.e. `FOO_BAR`)
  - Method names - may end with `?`, `!`, or `=`
* `nil` means
  - `nil.kind_of? Object` => true

### Ruby Variables

* Variables hold reference pointing to an object (not the object itself) likely stored in a heap

{% highlight ruby %}
test1 = "Test1"
puts "#{test1.class}, #{test1.object_id}"
test2 = test1
test2[0] = "B"
puts "Test1: #{test1}, #{test1.class}, #{test1.object_id}. Test2: #{test2}, #{test2.class}, #{test2.object_id}"
test1.freeze
test2[0] = "P"
{% endhighlight %}

### Ruby Arrays

* Arrays hold a collection of references pointing to objects in array index positions
* Array operation `[]` used for indexes is an instance method of class Array and may be overridden by subclasses
* Array index are >= 0. `nil` is returned if no object at an index. Providing negative index counts from the end
* Arrays allow Integer as key and any Object value
* Array Objects (Strings Only) Created and Initialised using Shortcut (i.e. `%w{ 99 a}`) # => `["99", "a"]`

- Create and initialise array object using array literal: `a = [1.23, "abc", 123]`
- Get class: `a.class`
- Get array length: `a.length`
- Get element value at index: `puts "element 1 is #{a[1]}"`
- Get element with no value: `a[3] # => nil`
- Get range of element values: `a[-2, 2] # => ["abc", 123] # [start, count]`
- Get range of element values: `a[-2..-1] # => ["abc", 123]`
- Get first n element values; `a.first(2) # => [1.23, "abc"]`
- Get last n element values; `a.last(2) # => ["abc", 123]`
- Set element values: `a[5] = 2.34 # => [1.23, "abc", 123, nil, nil, 2.34]`
- Inspect array: `a.inspect`
- Stack implemented using Array:
{% highlight ruby %}
stack = []
stack.push("a").push("c").pop # => "c"
{% endhighlight %}
- FIFO Queue implemented using Array:
{% highlight ruby %}
queue = []
queue.push("a").push("c").shift
puts queue  # => ["c"]
{% endhighlight %}

- Examples:

{% highlight ruby %}
# generate array where each element is word contained in a sentence string
def words_from_string(string)
  string.downcase.scan(/[\w']+/)
end
{% endhighlight %}

### Ruby Hash (aka Associative Arrays / Maps / Dictionaries)

* Indexed Data Structure collections of objects accessible using a key
* Hashes allow any Object as key or entry value
* Iterating over entries returns in same item order as when added

- Create and initialise hash literal with unique KV mapping: `h = { 'moo' => 'cow', :dog => 'bark' }`
- Alternative (Ruby v1.9+): `h = { 'moo': 'cow', dog: 'bark' }`
- Create and initialise array object with default value returned:

{% highlight ruby %}
h = Hash.new(0)
h[9999] # => 0
{% endhighlight %}

- Get class: `h.class`
- Get hash length: `h.length`
- Get element with no value: `h['dog']` # => nil, `h[:dog]` # => 'bark'
- Get element entry value for key: `h['blah']` # => 0

### Ruby Symbols

* Symbol literals are always unique and do not require a value. Used for Keys in a Hash

### Ruby Control Structures

* `if elseif else end`
* `_ if _`
* `while _ and _ \ end`
* `_ while _`

### Ruby Regular Expressions (built-in)

* Create RegEx object pattern between slash character delimiters (i.e. match x or y `/x|y/`)
* Match Operator `=~` to match against a RegEx and return starting position or `nil` (i.e. `puts 'hello' =~ /lo/` # => 3)
* Replace First Match using `sub` Substitution Method (i.e. `puts 'hello'.sub(/h|o/, 's') # => sello`)
* Replace All Matches using `gsub` Substitution Method (i.e. `puts 'hello'.gsub(/h|o/, 's') # => sells`)

### Ruby Blocks (similar to Anonymous Functions)

* Code Blocks are chunks of code between braces `{ ... }` (single line) or `do ... end` (multi-line) passed around as parameters associated with call to method invocations and callbacks
* Implement Block after method call/invocation and other parameters. Methods invoke associated block one or more times using `yield` statement
* Blocks are an additional implicit parameter passed to the method
* Variables declared inside block with same name as variables declared beforehand outside block in same scope are the same 
- Avoid name conflicts by declaring block-local variables after semicolon in parameter list

{% highlight ruby %}
a = "a"
["b"].each { |char; a| a = char }
puts a
["b"].each { |char| a = char }
puts a
{% endhighlight %}

* Parameters passed to a block are local to the block

{% highlight ruby %}
def owner(name)
  yield(name)
end
owner('luke') { |name| puts "#{name} owns" }
{% endhighlight %}

* Convert Block to an Object by Prefixing last parameter in method definition with ampersand `&my_block`
- When method is called Ruby converts the code block named `my_block` to an object of class Proc and assigns it to the method parameter as a variable
- Call the `call` method with parameters (if any) on the Proc object to invoke the code

{% highlight ruby %}
def pass_in_block(&my_block)
	my_block
end

block_as_object = pass_in_block { |my_param1| puts "Parameter1 is #{my_param1}" }
block_as_object.call(10) # => Parameter 1 is 10
{% endhighlight %}

* Example: Pass Multiple Blocks directly into Method

{% highlight ruby %}
def my_method(condition, large, small)
	condition ? large.call : small.call
end

5.times { |val| my_method(val >= 3, -> { puts "#{val} is large" }, -> { puts "#{val} is small" }) }
{% endhighlight %}

* Example: Pass Multiple Args and Block pointer parameter into Method

{% highlight ruby %}
proc1 = -> (*args, &block) { puts "args = #{args.inspect}"; block.call }
proc1.call(1, 2, 3) { puts "in block1" }
{% endhighlight %}

### Ruby I/O

* Output arguments with newline character after each `puts`
* Output arguments wihout newline `print`
* Outputs arguments under control of format string (i.e. `printf("Name: %s,\nAge: %5.2f", "luke", 35.67)` substitutes string and a float with min 5 chars with 2 after decimal point, and embeds a newline)
* Outputs of `puts` and `print` output to standard output by default
* Input read next line from standard input stream `gets` (i.e. `puts "old" if gets > 35.to_s`)
* Note: `gets` returns `nil` when reaches end of input (i.e. `while entry = gets \ print entry \ end`)
* Command-Line variable Arguments accessible using array `ARGV` (i.e. test.rb: `puts ARGV.size`, execute: `ruby test.rb hi bye` # => 2)
* Command-Line filename Arguments accessible using array `ARGF`

### Ruby Iterators

* `each` (`with_index`) instead of `for ... in` for iterating over array passing elements to block

{% highlight ruby %}
["a", "b"].each.with_index { |element, index| puts "Index #{index} is element: #{element}" }
{% endhighlight %}

* `map` or `collect` for iterating over array passing elements to block where new array constructed
* `reduce` or `inject` applying accumulator to collection returning final value
- initial iteration `accumulator` is set to parameter of `inject` (i.e. `3`)
- subsequent iterations `accumulator` is set to value returned by previous block call
- final value of `inject` is value returned by block the last time it is called

{% highlight ruby %}
[2,10,10].inject(3) {|accumulator, element| accumulator*element} # => 600
{% endhighlight %}

* `select` for filtering values from a collection
* `reject` is opposite of `select`
* `find` returns true upon first match in collection for given query

{% highlight ruby %}
%w( luke claudia ).each { |name| puts name }
2.times { print "*\n" }
1.upto(3) { |i| print i }
('a'..'f').each { |char| print char }
{% endhighlight %}

### Ruby Enumerators (external Iterators)

* Ruby built-in `Enumerator` class implements external iterators
* Create Enumerator object calling `to_enum` method (or `enum_for` in collections)
* Iterator Methods using Enumerators

{% highlight ruby %}
s = "abc"
a = [1, "a"]
h = { earth: "planet", person: "human" }

# Create Enumerators
enum_s = s.each_char
enum_a = a.to_enum
enum_h = h.to_enum

enum_a.next
enum_a.next
enum_h.next
enum_h.next

# Loop terminates after iterating over all Enumerator object values
loop { puts "#{enum_a.next}" }
loop { puts "#{enum_h.next}" }

# Enumerator built-in method with item value and index parameters
result = []
enum_s.each_with_index { |item, index| result << [item, index] }
result # => [["a", 0], ["b", 1], ["c", 2]]

# Create Enumerator explicitly
enum_s.enum_for(:each_char).to_a # => ["a", "b", "c"]
{% endhighlight %}

* Chains of Lazy Enumerators
- Lazy Enumerator instance returned by calling `.lazy` on Generator Enumerator to convert it and providing built-in support
to filter the infinite sequences (i.e. `select`, `map`) generated by an Enumerator.
- Lazy Enumerator allows calls (i.e. `select`) to return as it only consumes values on demand (not infinite sequence of values from Generator Enumerator) 
- Lazy Enumerator methods chained each return a new enumerator with specific logic applied to input data collection only when requested 

{% highlight ruby %}
# Helper method for Integer class
def Integer.all
  Enumerator.new do |yielder, n: 0|
    loop { yielder.yield(n += 1) }
  end.lazy
end

# Lazy filter methods as Procs (Closure) that return new Enumerator objects (for readability and reusability)
# Note: Proc called using `-> (arg1, arg2) { ... }` instead of `Proc.new { |params| ... }` or `lambda { |params| ... }` generates error if incorrect number of arguments passed to Proc
# Note: `->` represents Lambda character
# Reference: http://ruby-doc.org/core-2.2.0/Proc.html
multiple_of_three     = -> n { (n % 3).zero? }
contain_value_of_two  = -> n { n.to_s =~ /2/ }

# Retrieve array containing first 10 multiples of 3
p Integer
  .all
  .select(&multiple_of_three)
  .select(&contain_value_of_two)
  .first(10)
{% endhighlight %} 

* Blocks to define code to run under Transaction Control
- Simpler and less error prone approach using Blocks rather than Linear code

{% highlight ruby %}
class FileList

  # Class method called by block so files manage their own lifecycle
  def self.open_and_process(*args)
    begin
      f = File.open(*args)
      yield f
    rescue
      print "Error opening and processing file"
    else
      print "File opened and processed without error"
    ensure
      f.close() unless f.closed?
    end
  end
end

contents = []
FileList.open_and_process("file_list/testfile", "r") { |file| while line = file.gets; contents << line; end }
{% endhighlight %} 

### Ruby Object-Oriented System Design of Classes

* O-O Class Designs representing External Things: 
  - Identify resources to deal with using Class entities 
  - Represent each captured input data reading as a generated Class Instance Row
  - Represent all captured input data as collection of all Class Instance Objects
  - Decide Internal State (Class Instance Variables) and use `initialize` method to setup Object in usable state
  - Decide External State of Object (Attributes) appearance from outside Class to users (exposed using Attributes aka Getter/Setter Methods) that use the initialized state
  - Decide on other actions for Class (regular Class Instance Methods) that use the initialized state

* O-O Class Designs Pattern to representing Internal Things:

e.g.
  - Problem Statement A: we want to represent data for each Person on Earth
    - What does the representation? PeopleOnEarth class
  - Problem Statement B: we want to 1) consolidate and 2) summarise data feed inputs from CSV files
    - What does consolidation data? CsvReader class
    - What does summarising data? CsvReader class
  - Problem Statement C: we want to parse data from CSV
    - What does parsing data from CSV? Ruby CSV Library
    - Note: Create a PeopleOnEarth Object by extracting data from columns of each CSV row we iterate over and append the PeopleOnEarth Object Instance to a Class Instance Variable that was created in the initialize method 

* O-O File Organisation:
  - Organise source code into multiple Class files and a main driver program file
  - Benefits: Separate files instead of monolithic in same file to ease automated tests and ease class reuse

* O-O Class Access Control

  - Control access to Class Instance Object Methods to control changes to its state
  - Expose Logical Class Interface and hide details of implementation (prevent usage that causes tight coupling) 
  - Do not expose methods that may cause invalid Object state

* Create Class Definition

{% highlight ruby %}
class PeopleOnEarth

  # Initialize Object. Transfer and store parameter information in Local Instance Variables when constructed to set Object State before initialize returns 
  # Store unique State within Class Instance Object in distinct set of Local Instance Variables @

  def initialize(name, age)
    @name = name
    
    # Accept any object for age parameter that converts to a Float otherwise raise Exception
    @age = Float(age)
  end

  # Stored Instance Variables are available to Instance Methods of Class Instance Objects
  def to_s
    "Name: #{@name}, Age: #{@age}"
  end
end
{% endhighlight %}


* Create Class Instance Object of class PeopleOnEarth and Set Object's State with distinct identity
- Ruby allocates memory to hold uninitialised object
- Ruby calls the object's initialize method passing parameters given to `.new`
`a_person = PeopleOnEarth.new("luke", 35)`
* Pass a Class Instance Object to `puts` method that calls `to_s` to get string representation
- Without Overriding `to_s` Instance Method 
`p a_person` # => `<PeopleOnEarth:0x007f8b3285fe20>`
`puts a_person` # => `<PeopleOnEarth2:0x007fc4db892388 @name="luke", @age=35.0>`
- With Override of `to_s` Instance Method 
`p a_person` # => Name: luke, Age: 35
- Override default implementation of `to_s` to improve rendered formatting of objects

### Ruby Object Attributes to Access/Manipulate Object State

* Instance Variable Internal State is Private to a Class Instance Object
* Attributes of an Object are Externally visible (Public)

### Ruby Object Accessor Method Common Idiom and Shortcut (Getter)

* Accessor Methods Long Way to access and return values of Instance Variables

{% highlight ruby %}
def name
  @name
end

def age
  @age
end

a_person = PeopleOnEarth.new("luke", 35)
a_person.name
a_person.age
{% endhighlight %}

* Accessor Methods Shortcut `attr_reader`
  - Ruby decouples Class Instance Variables and Accessor Methods
  - `attr_reader` creates Accessor Methods so variables do not need to be declared
  - Uses Symbols to conveniently reference the name `:name` with value accessed with `name`

{% highlight ruby %}
attr_reader :name, :age
{% endhighlight %}

### Ruby Object Attributes (Setter Methods)

* `attr_accessor` - Both Read and Write Access
* `attr_reader` - Read-only Access
* `attr_writer` - Write-only Access

* Create Ruby method with name ending with `=` as target for assigning to Class Object Instance Variable

{% highlight ruby %}
...

attr_accessor :age

def age=(new_age)
  @age = new_age
end

...
# invoke Setter Method in the PeopleOnEarth Class Object Instance passing new age as argument
a_person.age = a_person.age + 1
puts "New Age: #{a_person.age}" 
{% endhighlight %}

### Ruby Object Virtual Attributes (Setter Methods)

* Virtual Attribute Methods create Virtual Instance Variables (hiding implementation and difference b/w Class Instance Variables and Calculated Values so outside class they appear like ordinary attribute but having no internal Class Instance Variable)
- Benefit: Uniform Access Principle - Internal Class implementation changes do not impact and require changes to code using the Class
- Note: Floating-point numbers do not always have exact internal representation and calling Integer method on inexact value truncates rounding down. Overcome by adding 0.5 before calling Integer method to round up instead.
- Note: Use `BigDecimal` for financial calculations

{% highlight ruby %}
def age_in_months
  Integer(age*12 + 0.5)
end

...

a_person.age_in_months
{% endhighlight %}

### External Dependencies

{% highlight ruby %}
# load library external standard CSV dependency
require csv

# load custom Class dependency (from file in same directory)
require_relative 'people_on_earth'
{% endhighlight %}

### Access Control

* Note: `initialize` method is always Private
* Note: Methods are Public by default
* Note: Access control determined *dynamically* as program runs (not statically)

* Public Methods - No access control
* Protected Methods - Only invokable by any Class Instance Object of defining class and associated subclasses
* Private Methods - Only callable in context of current calling object receiver (`self`)

* Approach #1 - Set default access control of subsequently defined methods

{% highlight ruby %}
class MyClass
  def method1
  end
  
protected # or private/public
  def method2
  end

end 
{% endhighlight %}

* Approach #2 - Set default access control of named methods listed as arguments to access control function

{% highlight ruby %}
class MyClass

  def method1
  end
  
  def method2
  end
  
  def method3
  end
  
  def method4
  end
  
  # public, protected, or private
  public    :method1, method2
  protected :method3
  private   
end
{% endhighlight %}

### Ruby Sharing Functionality
- Avoid duplicating functionality (DRY codebase)
- Generic functionality to inject across different classes
- Ruby is Single-Inheritance language as a Ruby class has only one direct parent
- Ruby provides controlled multiple-inheritance-like capability when Ruby classes include functionality of any number of Mixins

* Class-Level Inheritance
- Inheritance allows creation of subclasses (child of parent superclass)
- Child inherits capabilities of parent class including methods
- Calling `super` sends a message to the parent of the current object requesting to invoke method of same name and passing parameter
- Object-Oriented programming requires subclasses to ensure inherited initialisation gets run with a call to `super` in initialise method of subclass 

{% highlight ruby %}
class Parent
  def public_parent_method
    puts "public_parent_method of #{self}"
  end

  protected
  
    def protected_parent_method
      puts "protected_parent_method of #{self}"
    end

  private
  
    def private_parent_method
      puts "private_parent_method of #{self}"
    end
end

class Child < Parent
end

c = Child.new
c.public_parent_method
Parent.superclass
Child.superclass
{% endhighlight %}

* Mixins (using Modules)
- Modules are not a class and do not have instances
- `include` references a Module. `require` first when Module in separate file
- `include` Module in class definitions to make Module Instance Methods available to class
- Mixins that require their own state to be stored should be written as a class

* Pub/Sub Observable O-O Design Pattern
- Reference [https://ruby-doc.org/stdlib-1.9.3/libdoc/observer/rdoc/Observable.html](https://ruby-doc.org/stdlib-1.9.3/libdoc/observer/rdoc/Observable.html)